package io.joern.c2cpg.vulnerability
import io.joern.c2cpg.parser.FileDefaults
import io.joern.c2cpg.testfixtures.CCodeToCpgSuite
import io.shiftleft.codepropertygraph.generated.Operators
import io.shiftleft.codepropertygraph.generated.nodes.AstNode
import io.shiftleft.semanticcpg.language.{ICallResolver, NoResolve, iterOnceToAstNodeDot, toNodeTypeStarters}
import io.shiftleft.semanticcpg.language._
class Overflow extends CCodeToCpgSuite(FileDefaults.CPP_EXT){
  implicit  val resolver : ICallResolver = NoResolve
  override val code: String = {
  """
    | class Foo {
    |int sellerBalance = 0;
    |
    |void add(uint value) {
    |    sellerBalance += value; // possible overflow
    |}
    |
    |bool safe_add(uint value) {
    |    require(value + sellerBalance >= sellerBalance);
    |    sellerBalance += value;
    |}
    |}""".stripMargin
  }
  "should throw overflow" in {
//      println(cpg.typeDecl.dotAst.head)
      val overflowableArguments = cpg.call
        .nameExact(Operators.addition, Operators.assignmentPlus)
        .where(_.argument(1).typ.fullNameExact("int", "long"))
        .filterNot(_.argument.isLiteral.size == 2)
        .argument
      val argSet:Set[AstNode] = overflowableArguments.collect { case x: AstNode => x }.toSet
//      overflowableArguments.foreach(x => println(x.code))
      val tmp = overflowableArguments.whereNot(_.dominatedBy.containsCallTo(".*require.*")
        .filter(_.ast.exists(argSet.contains)))
        .astParent
        .isExpression
        .dedup
      println(tmp.size)
      tmp.foreach(x => println(x.code))
  }
}
